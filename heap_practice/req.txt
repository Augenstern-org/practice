# 小行星采矿站管理系统

## 一、项目总体要求（必须实现）
目标：实现可交互命令行“采矿站管理器”，能创建/销毁
采矿站与机器人，模拟能量消耗与矿石产出，能量随矿
石回血（有上限），用new/delete与<memory>智能指针
正确管理对象生命周期。

### 核心类与职责：
• PowerCore
  • 成员：int power（当前能量），int capacity（上限），
	int regen_per_ore（每单位矿石回复能量）
  • 方法：
  • bool consume(int amount)：尝试消耗能量，不足
	返回false（不改变能量）。
  • void recharge(int ore)：能量=ore*regen_per_ore，
	不超capacity。
  • void showStatus()：打印当前power/capacity。

• Robot（可继承）
  • 成员：std::string id、type，int energyCost（每
	tick消耗）、oreOutput（每tick挖矿量），连接
	PowerCore的引用/指针
  • 方法：virtual int work()：尝试工作（消耗能量
	返矿石量）；能源不足返0且“停机”；showInfo()。

• MiningStation
  • 成员：名称、机器人容器（裸指针/智能指针）、
	指向PowerCore（共享）
  • 方法：addRobot(...)、removeRobot(id)、tick()（所
	有机器人work()，统计矿石回传PowerCore）、
	showStatus()。

### 交互功能（命令行菜单）：
• 建立/删除采矿站
• 查看采矿站详情（机器人列表、能源状态、累计矿石）
• 向指定采矿站加机器人（参数：id、type、energyCost、
	oreOutput）
• 按id删除机器人
• 手动运行tick()（或循环若干次），显每次结果（机器
	人消耗/产出、能源变化）
• 查看PowerCore的use_count()（shared_ptr实现里）

### 边界与约束：
• PowerCore::power永远在[0, capacity]
• recharge与consume要原子式更新（不外部直接操作power）
• 机器人能量不足时，返回停机并在输出标记
• 内存管理：不同阶段用不同方式（见分步）

### 验收测试（最小）：
1.创建采矿站加2个机器人，PowerCore初始power=100，
	capacity=100，regen_per_ore=2。
2.运行1个tick：机器人总消耗≤恢复量则power不减
	或少增；过多则降0且部分停机。
3.加减机器人无内存泄漏（Step1用valgrind或注意
	delete，Step2+用智能指针）。
4.shared_ptr方案下，打印PowerCore引用计数
	use_count()与预期一致。

## 二、分步骤实现与学习建议（每步明“练什么”）
### Step 0 — 准备（必做）
目标：搭建项目骨架，熟悉编译与运行流程。
• 内容：
  • 新建main.cpp，建CMakeLists.txt或简单g++编译
	命令。
  • 创建空类文件PowerCore.h/cpp、Robot.h/cpp、
	MiningStation.h/cpp，包含到main。
  • 在main打印欢迎菜单（静态，不实现功能）。
• 练习内容：项目结构、编译流程、头文件与源文件组织、基础I/O。
• 如何验证：能编译并运行输出菜单文本。

### Step 1 — 裸指针版本（练new/delete与手动管理）
目标：用new/delete实现所有对象（MiningStation、
Robot、PowerCore均裸指针），实现基本功能
（add/remove/tick/show），确保手动释放内存。

要求：
• MiningStation中std::vector<Robot*> robots;
• PowerCore* core;（创建站点时new并传给机器人）
• addRobot(Robot* r)接受new的Robot*并push_back
• removeRobot(id)要delete对应指针并从vector移除
（释放后置nullptr或移出）
• MiningStation::tick()：
  • 遍历robots，调robot->work()（尝试core->consume()，
成功返oreOutput，否则0）
  • 累计总矿石totalOre，遍历后调core->recharge(totalOre)
  • 打印每个机器人工作状况与最终core状态

练习点：
• 正确用new/delete，避免悬挂指针与重复释放
• 手动维护容器内原始指针
• 理解对象所有权（谁负责释放）

实现提示：
• removeRobot用erase-remove_if模式：先delete ptr，
再erase
• 创建Robot后，addRobot不再delete（责任转容器）
• 程序退出前手动遍历所有采矿站、机器人delete（或
写clear()）

测试：
• 加减机器人、重复操作后，用valgrind查内存泄漏
和重复释放。

### Step 2 — unique_ptr版本（练std::unique_ptr）
目标：Robot*改为std::unique_ptr<Robot>，
MiningStation用std::vector<std::unique_ptr<Robot>>
管理机器人，PowerCore仍裸指针或改智能指针（建议
后续用shared_ptr/unique_ptr）。

要求：
• 加机器人用std::make_unique<Robot>(...)并move进
addRobot。
• removeRobot只需从vector移除元素（unique_ptr自
动释放）。
• MiningStation接口可为
	void addRobot(std::unique_ptr<Robot> r)

练习点：
• 理解unique_ptr独占所有权与std::move必要性
• 学把裸指针容器换智能指针容器，减手动delete错误
• 练修改接口适配所有权语义（传参、返回值）

实现提示：
• addRobot(std::unique_ptr<Robot> r) { robots.push_back(
std::move(r)); }
• main中：station.addRobot(std::make_unique<Robot>(...));
• removeRobot用erase-remove_if，匹配->id，无需手动delete

测试：
• 重复加减机器人确认无内存泄漏（运行多次tick，
看生命周期变化）
• 尝试复制unique_ptr（应报编译错），观编译器强制
改思路

### Step 3 — 
shared_ptr：引入PowerCore共享（std::shared_ptr）
目标：PowerCore作共享资源（std::shared_ptr<PowerCore>），
每个机器人持shared_ptr指向同一核心；
MiningStation也持shared_ptr（use_count()反映引用数）。

要求：
• 创建auto core = std::make_shared<PowerCore>(
initialPower, capacity, regen_rate);
• 创建机器人时传core（机器人存std::shared_ptr<PowerCore>
或std::weak_ptr，见变体）
• tick()中能打印core.use_count()（含所有shared_ptr拷贝）

练习点：
• 学shared_ptr引用计数语义
• 了解use_count()含义（并发环境不可依赖）
• 体验共享资源管理便利与风险（防循环引用）

实现提示：
• 机器人若仅观察核心（如监控器类），可改std::weak_ptr，
避免增引用计数
• 防机器人与核心循环引用（核心持机器人指针且机器
人持core shared_ptr会泄漏；需用weak_ptr断开）

测试：
• 打印use_count()：创core（1），传MiningStation（+1），
传n个机器人（各+1），查数值合理。
• 销毁采矿站或删机器人后，use_count()下降，所有
引用消失则core析构（析构函数打日志确认）。

### Step 4 — 能源“自我供给”机制（核心功能）（练模拟与状态更新）
目标：实现矿石产出→能源回复闭环逻辑；实现tick循环，
处理停机条件与能量上限。

要求：
• Robot::work()：
  • 判断core->canRun(energyCost)（或尝试consume）
  • 能量足：core->consume(energyCost)，返oreOutput
  • 不足：返0，标记机器人停机（Robot内存bool active）
• MiningStation::tick()：
  • 遍历robots，调work()，累计totalOre
  • 遍历后执行core->recharge(totalOre)
  • 输出每个机器人消耗/产出与core前后能量值
• 能量边界：power不超capacity；consume不使power负

练习点：
• 状态机/状态更新（机器人active/inactive）
• 业务逻辑实现（能耗计算、产出累加、能量回复）
• 处理边界（上下限、整数溢出检查）

实现提示：
• 做好日志输出，便观察每次tick细节
• PowerCore::consume尽量一次返bool，不外部直
接调power
• 可实现tick(int n)一次运行n个tick，每个打summary

测试：
• 设计场景（消耗>回收、等于、少于），运行若干tick，
观power变化符预期
• 测power降0时机器人停机，加矿石或手动充能恢复

### Step 5 — 多态与机器人类型差异（练多态/继承）
目标：Robot设为基类，不同类型机器人（Driller、
Analyzer、Digger等）继承并复写work()，体现多态。

要求：
• class Robot { virtual int work() = 0; ... };
• 不同子类有不同能耗/产出/特殊效果（如Analyzer产
出少但每产出提regen_per_ore bonus）
• MiningStation容器存std::vector<std::unique_ptr<Robot>>
（多态与智能指针结合）

练习点：
• 虚函数与抽象类
• 智能指针+多态（unique_ptr持Derived）
• 设计扩展友好的类层次

实现提示：
• 用std::make_unique<Driller>(...)创建子类对象并
move到容器
• work()返挖矿量，必要时用dynamic_cast处理特定
子类（少用）

测试：
• 加不同子类机器人，观行为差异
• 扩新机器人类型，确认系统不改核心逻辑可运行（开
闭原则测试）

### Step 6 — 高级可选（练weak_ptr、跨站共享与持久化）
目标：实现复杂用例与工程实践能力训练。
• 用std::weak_ptr：
  • 例：监控模块/外部接口持weak_ptr指向PowerCore，
用前lock()查是否存在。
• 多采矿站共享一个PowerCore（跨站能源中心）
  • 练跨对象共享与协调（可能有竞争，并发须加锁）
• 持久化：保存/加载采矿站和机器人状态到文本文件
（练文件I/O）
• 异常与错误处理（如重复id、无效id、IO错误）

练习点：
• weak_ptr正确使用（防空悬引用）
• 复杂所有权图（多站点与多机器人共享关系）
• 把程序做“工程化”产物（持久化、错误处理）

测试：
• 模拟站点销毁后weak_ptr.lock()返空
• 保存状态、退出、重新加载继续模拟（验持久化完整）

## 三、实现建议与常见坑（实战小贴士）
• 所有权清晰：谁new谁delete（Step1），后用智能指
针明确生命周期负责人。
• 防循环引用：PowerCore若需知机器人（不推荐），
机器人持shared_ptr，核心持weak_ptr。
• 接口设计：优先用value/uniqueptr/sharedptr传参，
非裸指针，明所有权。
• 不信外部数据：addRobot查id唯一；removeRobot处
理找不到情况。
• 日志与断言：多打状态（能量、use_count、机器人
状态），写assert查不变量（power非负、≤capacity）。
• 逐步测试：每步完写小demo（1-2机器人、几个tick），
确认结果再继续。

## 四、验收示例（小剧本）
1. 建Titan-A，创PowerCore(power=500, capacity=1000,
regen_per_ore=2)。
2. 加Driller(RB-001, energyCost=10, oreOutput=5)和
Analyzer(RB-002, energyCost=5, oreOutput=3)。
3. 运行10个tick，观：power波动不超1000；use_count()=
station + n robots。
4. 删RB-002，use_count()减；删站点后PowerCore销毁
（查析构日志）。

## 五、学习路线建议（如何按顺序练）
• 先完Step 0→Step1（掌握new/delete）
• 再做Step2→Step3（迁智能指针，理解所有权与共享）
• 接着实Step4（业务逻辑：耗能与回血）
• 然后做Step5（多态与扩展）
• 最后试Step6（weak_ptr、跨站共享、持久化）
每步完至少做3个小用例测试（加减/多tick、异常、
边界），观输出日志验状态正确。