#version 450

#extension GL_EXT_scalar_block_layout : enable

// 工作组大小
layout(local_size_x = 16, local_size_y = 16, local_size_z = 1) in;

struct PixelResult {
    // Compute Shader 计算出的最终颜色
    vec4 finalColor;
    // Compute Shader 计算出的击中点位置（用于深度测试）
    vec4 hitPosition_and_padding;
    vec4 pathLength_and_padding;
};


// -----------------------------------------------------------
// 尚未在 cpp 文件中添加的结构体与布局
// -----------------------------------------------------------
//struct CameraParams{
//    vec4 pos;
//};
//
//struct Object{
//    vec4 pos;
//};
//
//layout(std140, binding = 0) uniform CameraParams {
//    mat4 view;
//    mat4 proj;
//    // ... 其他参数 ...
//    float screenWidth;
//    float screenHeight;
//} ubo;

layout(set = 0, binding = 0) uniform Params {
    vec3 cameraPos; float _pad0;
    vec3 cameraDir; float _pad1;
    vec3 cameraUp;  float _pad2;
    vec3 cameraRight; float _pad3;

    vec2 screenSize; vec2 _pad4;

    vec3 objectPos; float objectRadius;
} params;

layout(set = 0, binding = 1) buffer ResultImage {
    vec4 pixels[];
};
// -----------------------------------------------------------

vec3 traceGeodesicRay(vec3 origin, vec3 direction) {
    // 这里写你的 geodesic 数值积分（RK4 / RK2 / Euler）
    // 返回最终颜色或者最终命中点，都可以
    //
    // 示例：简单返回方向，实际请替换
    return normalize(direction);
}


void main() {
    uvec2 px = gl_GlobalInvocationID.xy;
    if (px.x >= uint(params.screenSize.x) ||
    px.y >= uint(params.screenSize.y))
    return;

    uint index = px.x + px.y * uint(params.screenSize.x);

    // 将 pixel 坐标映射到 [-1, 1]
    vec2 uv = (vec2(px) / params.screenSize) * 2.0 - 1.0;

    // 构造射线方向
    vec3 dir = normalize(
        params.cameraDir +
        uv.x * params.cameraRight +
        uv.y * params.cameraUp
    );

    // geodesic / ray marching / geometric 函数
    vec3 col = traceGeodesicRay(params.cameraPos, dir);

    // 写出颜色
    pixels[index] = vec4(col, 1.0);
}